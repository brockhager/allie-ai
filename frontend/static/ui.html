<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Allie ‚Äî Tabbed Conversations</title>
<style>
  :root{--bg:#0f1720;--panel:#0b1220;--muted:#9ca3af;--text:#e6eef6;--accent:#60a5fa;--me:#0b84ff}
  html,body{height:100%;margin:0;font-family:Inter,system-ui,Segoe UI,Arial;color:var(--text);overflow:hidden}
  .app{width:100%;height:100vh;background:var(--panel);border-radius:0;box-shadow:none;display:flex;overflow:hidden;box-sizing:border-box}
  .sidebar{width:260px;padding:12px;border-right:1px solid rgba(255,255,255,0.03);display:flex;flex-direction:column}
  .tabs{display:flex;flex-wrap:wrap;gap:6px}
  .tab{padding:8px 10px;border-radius:8px;background:transparent;color:var(--muted);cursor:pointer;border:1px solid transparent}
  .tab.active{background:rgba(255,255,255,0.05);color:var(--text);border-color:rgba(255,255,255,0.07)}
  .tab-controls{margin-top:10px;display:flex;gap:6px;flex-wrap:wrap}
  button{background:var(--accent);color:#021125;border:none;padding:8px 12px;border-radius:8px;cursor:pointer;font-weight:600}
  /* Larger chat input and send button adjustments */
  /* Make the main prompt textarea ~3x taller for easier typing */
  #prompt{
    height:120px; /* ~3x typical single-line input height */
    padding:14px;
    font-size:16px;
    border-radius:10px;
    border:1px solid rgba(255,255,255,0.04);
    background:#ffffff;
    color:#021125;
    resize:vertical;
    min-height:84px;
    max-height:320px;
  }

  /* Make the SEND button visually and interactively larger (approx 3x) */
  #sendBtn{
    padding:24px 36px;
    font-size:18px;
    border-radius:10px;
    transform-origin:center;
  }

  /* Ensure the inputbar layout accommodates larger controls */
  /* Anchor the input bar to the bottom so it never moves and stays visible.
    Position left/right to account for the sidebar and memory panel widths. */
  .inputbar{display:flex;gap:16px;padding:12px;position:fixed;left:260px;right:240px;bottom:0;background:rgba(255,255,255,0.96);z-index:40;border-top:1px solid rgba(0,0,0,0.06);box-shadow:0 -8px 24px rgba(2,6,23,0.28)}
  .inputbar > div{display:flex;flex-direction:column;align-items:flex-end}
  button.secondary{background:transparent;color:var(--muted);border:1px solid rgba(255,255,255,0.08)}
  .main{flex:1;display:flex;flex-direction:column;min-height:0}
  .header{padding:12px 16px;border-bottom:1px solid rgba(255,255,255,0.03);display:flex;align-items:center;gap:12px}
  .status-section{margin-left:auto;display:flex;flex-direction:column;gap:4px}
  .status-label{font-size:11px;color:var(--muted);text-transform:uppercase;letter-spacing:0.5px}
  .status-value{font-size:13px;color:var(--text);font-weight:500}
  /* Standard chat flow: older messages at top, newest at bottom.
    Add bottom padding so content is not covered by the fixed input bar. */
  .messages{flex:1;padding:16px;padding-bottom:240px;overflow-y:auto;overflow-x:hidden;display:flex;flex-direction:column;gap:12px;min-height:0;background:linear-gradient(180deg,rgba(255,255,255,0.02),transparent)}
  .row{display:flex;gap:10px;align-items:flex-end}
  .bubble{max-width:75%;padding:12px 14px;border-radius:13px;font-size:15px;line-height:1.4}
  .bubble.me{margin-left:auto;background:linear-gradient(90deg,var(--me),#1f7fe8);color:#021125;border-bottom-right-radius:6px}
  .bubble.them{margin-right:auto;background:#111827;border:1px solid rgba(255,255,255,0.02)}
  .bubble.reported-false{border-color:rgba(255,99,99,0.6);box-shadow:0 0 0 2px rgba(255,99,99,0.03) inset}
  .false-label{display:inline-block;margin-left:8px;background:rgba(255,99,99,0.12);color:#ff6b6b;font-size:11px;padding:2px 6px;border-radius:6px}
  .meta{font-size:12px;color:var(--muted);margin-top:6px}
  .sidebar-status{margin-bottom:16px;padding:12px;border-radius:8px;background:rgba(255,255,255,0.02);border:1px solid rgba(255,255,255,0.05)}
  .sidebar-status-label{font-size:12px;color:var(--muted);text-transform:uppercase;letter-spacing:0.5px;margin-bottom:4px}
  .sidebar-status-value{font-size:16px;color:var(--text);font-weight:500}
  .learning-status{font-size:12px;color:var(--muted);margin-bottom:8px}
  .learning-controls{display:flex;flex-direction:column;gap:6px}
  .learning-btn{background:var(--accent);color:#021125;border:none;padding:6px 10px;border-radius:6px;cursor:pointer;font-size:12px;font-weight:600}
  .learning-btn.secondary{background:transparent;color:var(--muted);border:1px solid rgba(255,255,255,0.08)}
  .learning-btn:disabled{background:#666;color:#999;cursor:not-allowed}
  .memory-panel{width:240px;padding:12px;border-left:1px solid rgba(255,255,255,0.03);display:flex;flex-direction:column;gap:12px;overflow-y:auto}
  .memory-stats-card{background:rgba(255,255,255,0.02);border:1px solid rgba(255,255,255,0.05);border-radius:8px;padding:12px}
  .memory-stats-title{font-size:13px;color:var(--accent);font-weight:600;margin-bottom:8px;display:flex;align-items:center;gap:6px}
  .memory-stat-row{display:flex;justify-content:space-between;align-items:center;padding:6px 0;border-bottom:1px solid rgba(255,255,255,0.03)}
  .memory-stat-row:last-child{border-bottom:none}
  .memory-stat-label{font-size:12px;color:var(--muted)}
  .memory-stat-value{font-size:14px;color:var(--text);font-weight:600}
  .memory-category-item{display:flex;justify-content:space-between;font-size:11px;padding:4px 0;color:var(--muted)}
  .memory-refresh-btn{background:transparent;color:var(--accent);border:1px solid rgba(96,165,250,0.3);padding:6px 10px;border-radius:6px;cursor:pointer;font-size:11px;width:100%;margin-top:8px;font-weight:600;transition:all 0.2s}
  .memory-refresh-btn:hover{background:rgba(96,165,250,0.1);border-color:var(--accent)}
  .memory-refresh-btn:active{transform:scale(0.95)}
  .memory-refresh-btn.refreshing{opacity:0.5;pointer-events:none}
</style>
</head>
<body>
<div class="app" role="application" aria-label="Allie chat UI">
  <aside class="sidebar">
    <h3 style="margin:6px 4px;color:var(--accent);font-size:14px">Conversations</h3>
    <div class="sidebar-status">
      <div class="sidebar-status-label">Status</div>
      <div class="sidebar-status-value" id="status">Initializing...</div>
    </div>
    <div class="tabs" id="tabs"></div>
    <div class="tab-controls">
      <button id="newConv">New</button>
      <button id="renameConv" class="secondary">Rename</button>
      <button id="deleteConv" class="secondary">Delete</button>
    </div>

    <div class="learning-panel">
      <h4 style="margin:0 0 8px 0;color:var(--accent);font-size:13px">Learning System (Auto)</h4>
      <div id="learningStatus" class="learning-status">Initializing learning system...</div>
      <div class="learning-controls">
        <button id="checkLearningBtn" class="learning-btn secondary">Refresh Status</button>
        <button id="startLearningBtn" class="learning-btn" style="display:none">Manual Trigger</button>
        <button id="stopLearningBtn" class="learning-btn secondary" style="display:none">Stop Learning</button>
        <button id="viewHistoryBtn" class="learning-btn secondary">View History</button>
      </div>

      <!-- Learning Activity Feed -->
      <div class="learning-activity" style="margin-top:12px;">
        <h5 style="margin:0 0 6px 0;color:var(--accent);font-size:11px;text-transform:uppercase;letter-spacing:0.5px">Recent Activity</h5>
        <div id="learningActivityFeed" class="learning-activity-feed" style="max-height:120px;overflow-y:auto;font-size:11px;color:var(--muted);background:rgba(255,255,255,0.02);border-radius:6px;padding:8px;">
          <div style="text-align:center;padding:8px;">Loading activity...</div>
        </div>
      </div>
    </div>

    <div style="margin-top:auto;font-size:13px;color:var(--muted);padding-top:12px">Local model ¬∑ <span id="modelName">tinyllama</span></div>
  </aside>

  <main class="main">
    <div class="header">
      <div style="font-weight:600" id="convTitle">Allie</div>
      <div style="flex:1"></div>
      <button id="exportAllBtn" class="secondary">Export All</button>
      <button id="exportBtn" class="secondary">Export</button>
  <button id="quickTeachBtn" class="secondary">Quick Teach</button>
      <input id="importAllFile" type="file" style="display:none" accept=".json"/>
      <button id="importAllBtn" class="secondary">Import All</button>

      <input id="importFile" type="file" style="display:none" accept=".json"/>
      <button id="importBtn" class="secondary">Import</button>
    </div>

    <div id="chatPanel">
      <div class="messages" id="messages" aria-live="polite"></div>

      <div class="inputbar">
      <textarea id="prompt" placeholder="Send a message..."></textarea>
      <div style="display:flex;flex-direction:column;gap:6px;align-items:flex-end">
        <div style="display:flex;flex-direction:column;gap:6px">
          <button id="sendBtn">Send</button>
          <button id="stopBtn" class="secondary" style="display:none">Stop</button>
        </div>
        <div style="width:120px;text-align:right;color:var(--muted);font-size:12px">
          Max tokens<br/><input id="maxTokens" type="number" value="120" min="1" style="width:80px;margin-top:6px"/>
        </div>
      </div>
      </div>
    </div>

    <!-- Embedded Quick Teach panel (hidden by default) -->
    <div id="quickTeachPanel" style="display:none;padding:16px;overflow:auto;">
      <div style="max-width:820px;margin:0 auto">
        <h2 style="margin:0 0 8px 0;color:var(--accent)">Quick Teach</h2>
        <div style="color:var(--muted);font-size:13px;margin-bottom:12px">Quickly report incorrect replies, add corrections to memory, or request a better answer.</div>

        <label style="display:block;margin-top:8px;font-size:13px;color:var(--muted)">Conversation ID (optional)</label>
        <input id="qtConvId" placeholder="e.g. c-0" />

        <label style="display:block;margin-top:8px;font-size:13px;color:var(--muted)">Message Index (optional)</label>
        <input id="qtMsgIndex" placeholder="index of assistant message in conversation (0-based)" />

        <label style="display:block;margin-top:8px;font-size:13px;color:var(--muted)">User prompt / Original question (optional)</label>
        <textarea id="qtUserPrompt" rows="2" placeholder="The original user prompt that led to the incorrect answer"></textarea>

        <label style="display:block;margin-top:8px;font-size:13px;color:var(--muted)">Incorrect assistant reply (optional)</label>
        <textarea id="qtBadReply" rows="3" placeholder="The assistant reply you want to flag as incorrect"></textarea>

        <label style="display:block;margin-top:8px;font-size:13px;color:var(--muted)">Correct answer / Correction (recommended)</label>
        <textarea id="qtCorrection" rows="4" placeholder="Provide the corrected answer or preferred completion"></textarea>

        <div style="display:flex;gap:8px;margin-top:12px">
          <button id="qtMarkFalseBtn">Mark as Wrong (Report)</button>
          <button id="qtAddMemoryBtn" class="secondary">Add Correction to Memory</button>
          <button id="qtAddNegativeBtn" class="secondary">Add as Negative Example</button>
          <button id="qtRequestBetterBtn" class="secondary">Request Better Answer</button>
        </div>

        <div id="qtStatus" class="feedback" style="display:none;margin-top:12px"></div>
      </div>
    </div>

  </main>

  <aside class="memory-panel">
    <div class="memory-stats-card" style="background:rgba(96,165,250,0.08);border-color:rgba(96,165,250,0.2)">
      <div class="memory-stats-title">
        <span>‚≠ê</span>
        <span>Learning Score</span>
      </div>
      <div style="text-align:center;padding:8px 0">
        <div style="font-size:32px;font-weight:700;color:var(--accent)" id="learningScore">-</div>
        <div style="font-size:11px;color:var(--muted);margin-top:4px" id="learningScoreLabel">Calculating...</div>
      </div>
    </div>

    <div class="memory-stats-card">
      <div class="memory-stats-title">
        <span>üß†</span>
        <span>Memory Stats</span>
      </div>
      <div class="memory-stat-row">
        <span class="memory-stat-label">Total Facts</span>
        <span class="memory-stat-value" id="memTotalFacts">-</span>
      </div>
      <div class="memory-stat-row">
        <span class="memory-stat-label">Active</span>
        <span class="memory-stat-value" id="memActiveFacts">-</span>
      </div>
      <div class="memory-stat-row">
        <span class="memory-stat-label">Outdated</span>
        <span class="memory-stat-value" id="memOutdatedFacts">-</span>
      </div>
      <div class="memory-stat-row">
        <span class="memory-stat-label">Keywords</span>
        <span class="memory-stat-value" id="memKeywords">-</span>
      </div>
      <button id="memRefreshBtn" class="memory-refresh-btn">‚Üª Refresh</button>
    </div>

    <div class="memory-stats-card">
      <div class="memory-stats-title">
        <span>üìÇ</span>
        <span>Categories</span>
      </div>
      <div id="memCategories" style="max-height:150px;overflow-y:auto">
        <div style="font-size:11px;color:var(--muted);text-align:center;padding:8px">Loading...</div>
      </div>
    </div>

    <div class="memory-stats-card">
      <div class="memory-stats-title">
        <span>üîó</span>
        <span>Sources</span>
      </div>
      <div id="memSources" style="max-height:120px;overflow-y:auto">
        <div style="font-size:11px;color:var(--muted);text-align:center;padding:8px">Loading...</div>
      </div>
    </div>

    <div class="memory-stats-card">
      <div class="memory-stats-title">
        <span>‚è±Ô∏è</span>
        <span>Last Updated</span>
      </div>
      <div style="font-size:11px;color:var(--muted);text-align:center;padding:8px" id="memLastUpdate">Never</div>
    </div>
  </aside>
</div>

<script>
/* Tabbed conversations UI with server-side persistence.
   Endpoints used:
   - GET    /api/conversations
   - POST   /api/conversations
   - PUT    /api/conversations/{id}
   - DELETE /api/conversations/{id}
   - POST   /api/generate  { prompt, max_tokens }
*/

const tabsEl = document.getElementById('tabs');
const messagesEl = document.getElementById('messages');
const promptEl = document.getElementById('prompt');
const sendBtn = document.getElementById('sendBtn');
const stopBtn = document.getElementById('stopBtn');
const newBtn = document.getElementById('newConv');
const renameBtn = document.getElementById('renameConv');
const deleteBtn = document.getElementById('deleteConv');
const convTitle = document.getElementById('convTitle');
const statusEl = document.getElementById('status');
const exportBtn = document.getElementById('exportBtn');
const importBtn = document.getElementById('importBtn');
const importFile = document.getElementById('importFile');
const maxTokensEl = document.getElementById('maxTokens');
const exportAllBtn = document.getElementById('exportAllBtn');

// Learning elements
const learningStatusEl = document.getElementById('learningStatus');
const checkLearningBtn = document.getElementById('checkLearningBtn');
const startLearningBtn = document.getElementById('startLearningBtn');
const stopLearningBtn = document.getElementById('stopLearningBtn');
const viewHistoryBtn = document.getElementById('viewHistoryBtn');
const learningActivityFeed = document.getElementById('learningActivityFeed');

// Memory statistics elements
const memTotalFacts = document.getElementById('memTotalFacts');
const memActiveFacts = document.getElementById('memActiveFacts');
const memOutdatedFacts = document.getElementById('memOutdatedFacts');
const memKeywords = document.getElementById('memKeywords');
const memCategories = document.getElementById('memCategories');
const memSources = document.getElementById('memSources');
const memLastUpdate = document.getElementById('memLastUpdate');
const memRefreshBtn = document.getElementById('memRefreshBtn');

// Learning score elements
const learningScore = document.getElementById('learningScore');
const learningScoreLabel = document.getElementById('learningScoreLabel');

// Quick Teach elements (embedded)
const qtConvId = document.getElementById('qtConvId');
const qtMsgIndex = document.getElementById('qtMsgIndex');
const qtUserPrompt = document.getElementById('qtUserPrompt');
const qtBadReply = document.getElementById('qtBadReply');
const qtCorrection = document.getElementById('qtCorrection');
const qtMarkFalseBtn = document.getElementById('qtMarkFalseBtn');
const qtAddMemoryBtn = document.getElementById('qtAddMemoryBtn');
const qtAddNegativeBtn = document.getElementById('qtAddNegativeBtn');
const qtRequestBetterBtn = document.getElementById('qtRequestBetterBtn');
const qtStatus = document.getElementById('qtStatus');

function qtShowStatus(txt, isError=false){
  qtStatus.style.display = 'block';
  qtStatus.style.background = isError ? 'rgba(255,0,0,0.04)' : 'rgba(0,255,0,0.03)';
  qtStatus.textContent = txt;
}

// Embedded Quick Teach handlers
qtMarkFalseBtn.onclick = async () => {
  const conv = qtConvId.value.trim() || null;
  const idx = qtMsgIndex.value.trim() || null;
  const correction = qtCorrection.value.trim() || null;
  if (!conv || !idx){
    if (!confirm('No conversation id/index provided. Report will add the correction as a negative example and memory entry. Continue?')) return;
  }
  try {
    const body = { conv_id: conv, message_index: idx !== null && idx !== '' ? Number(idx) : null, correction: correction };
    const resp = await fetch('/api/feedback/mark_false', { method: 'POST', headers:{'Content-Type':'application/json'}, body: JSON.stringify(body) });
    if (!resp.ok) throw new Error(await resp.text());
    qtShowStatus('Reported. Feedback recorded.');
  } catch (err){ qtShowStatus('Failed to report: ' + err.message, true); }
};

qtAddMemoryBtn.onclick = async () => {
  const fact = (qtCorrection.value.trim() || qtBadReply.value.trim());
  if (!fact) { qtShowStatus('No correction or fact provided', true); return; }
  try {
    const resp = await fetch('/api/hybrid-memory/add', { method: 'POST', headers:{'Content-Type':'application/json'}, body: JSON.stringify({ fact: fact, category: 'quick_teach', confidence: 0.9, source: 'quick_teach_ui' }) });
    if (!resp.ok) throw new Error(await resp.text());
    qtShowStatus('Added correction to hybrid memory');
  } catch (err){ qtShowStatus('Failed to add to memory: ' + err.message, true); }
};

qtAddNegativeBtn.onclick = async () => {
  const prompt = qtUserPrompt.value.trim();
  const completion = qtCorrection.value.trim();
  if (!prompt || !completion) { qtShowStatus('Provide both a prompt and a correction to add a negative example', true); return; }
  try {
    const resp = await fetch('/api/hybrid-memory/add', { method: 'POST', headers:{'Content-Type':'application/json'}, body: JSON.stringify({ fact: completion, category: 'negative_example', confidence: 0.95, source: 'quick_teach_ui' }) });
    if (!resp.ok) throw new Error(await resp.text());
    qtShowStatus('Added negative example (stored in memory as negative_example)');
  } catch (err){ qtShowStatus('Failed to add negative example: ' + err.message, true); }
};

qtRequestBetterBtn.onclick = async () => {
  const conv = qtConvId.value.trim();
  const idx = qtMsgIndex.value.trim();
  if (!conv || !idx){ qtShowStatus('conv_id and message_index required to request a better answer', true); return; }
  try{
    const resp = await fetch('/api/feedback/request_better', { method:'POST', headers:{'Content-Type':'application/json'}, body: JSON.stringify({ conv_id: conv, message_index: Number(idx) }) });
    if (!resp.ok) throw new Error(await resp.text());
    const j = await resp.json();
    qtShowStatus('Requested better answer. New reply appended to conversation.');
  } catch (err){ qtShowStatus('Failed to request better answer: ' + err.message, true); }
};

// Fetch and update memory statistics
async function updateMemoryStats() {
  try {
    // Add visual feedback
    memRefreshBtn.classList.add('refreshing');
    memRefreshBtn.textContent = '‚ü≥ Refreshing...';
    
    const resp = await fetch('/api/hybrid-memory/statistics');
    if (!resp.ok) {
      console.error('Failed to fetch memory stats:', resp.status);
      memRefreshBtn.classList.remove('refreshing');
      memRefreshBtn.textContent = '‚Üª Refresh';
      return;
    }
    
    const data = await resp.json();
    const stats = data.statistics;
    
    // Update main stats
    memTotalFacts.textContent = stats.total_facts || 0;
    memActiveFacts.textContent = stats.active_facts || 0;
    memOutdatedFacts.textContent = stats.outdated_facts || 0;
    memKeywords.textContent = stats.indexed_keywords || 0;
    
    // Update categories
    const categoriesHtml = Object.entries(stats.categories || {})
      .sort((a, b) => b[1] - a[1])
      .map(([cat, count]) => `
        <div class="memory-category-item">
          <span>${cat}</span>
          <span style="color:var(--text);font-weight:600">${count}</span>
        </div>
      `).join('') || '<div style="font-size:11px;color:var(--muted);text-align:center;padding:8px">No categories</div>';
    memCategories.innerHTML = categoriesHtml;
    
    // Update sources
    const sourcesHtml = Object.entries(stats.sources || {})
      .sort((a, b) => b[1] - a[1])
      .map(([src, count]) => `
        <div class="memory-category-item">
          <span>${src}</span>
          <span style="color:var(--text);font-weight:600">${count}</span>
        </div>
      `).join('') || '<div style="font-size:11px;color:var(--muted);text-align:center;padding:8px">No sources</div>';
    memSources.innerHTML = sourcesHtml;
    
    // Update last update time
    const now = new Date();
    memLastUpdate.textContent = now.toLocaleTimeString();
    
    // Add learning activity for memory stats update
    const totalFacts = stats.total_facts || 0;
    if (totalFacts > 0) {
      addLearningActivity(`Memory updated: ${totalFacts} facts, ${stats.active_facts || 0} active`, 'info');
    }
    
    // Remove visual feedback
    memRefreshBtn.classList.remove('refreshing');
    memRefreshBtn.textContent = '‚Üª Refresh';
    
  } catch (err) {
    console.error('Error updating memory stats:', err);
    memTotalFacts.textContent = 'Error';
    memActiveFacts.textContent = '-';
    memOutdatedFacts.textContent = '-';
    memKeywords.textContent = '-';
    
    // Remove visual feedback on error
    memRefreshBtn.classList.remove('refreshing');
    memRefreshBtn.textContent = '‚Üª Refresh';
  }
}

// Refresh button handler
memRefreshBtn.onclick = updateMemoryStats;

// Calculate and update learning score
async function updateLearningScore() {
  try {
    // Fetch both memory stats and learning status
    const [memResp, learningResp] = await Promise.all([
      fetch('/api/hybrid-memory/statistics'),
      fetch('/api/learning/status')
    ]);
    
    if (!memResp.ok || !learningResp.ok) {
      learningScore.textContent = '?';
      learningScoreLabel.textContent = 'Error fetching data';
      return;
    }
    
    const memData = await memResp.json();
    const learningData = await learningResp.json();
    
    const stats = memData.statistics;
    const dataStats = learningData.data_stats || {};
    
    // Calculate learning score (0-1000)
    // New approach: keep theoretical range 0-1000 but make the usual scores
    // more conservative by reweighting contributions and applying penalties
    // for false reports, stored negative examples, and outdated facts.
    // Components sum to 100 before scaling to 0-1000.

    const activeFacts = stats.active_facts || 0;
    const totalFacts = stats.total_facts || 0;
    const categoryCount = Object.keys(stats.categories || {}).length;
    const conversationCount = dataStats.total_conversations || 0;
    const qualityConversations = dataStats.quality_conversations || 0;

    // Defensive: some backends may expose false/negative counts in different places
    const falseReports = (stats.false_reports || dataStats.false_reports || 0);
    const negativeExamples = ((stats.categories && (stats.categories.negative_example || stats.categories['negative_example'])) || 0);
    const outdatedFacts = stats.outdated_facts || 0;

    let rawScore = 0;

    // Active facts (0-30)
    // Need ~150 active facts to reach the max of this component
    rawScore += Math.min(activeFacts / 5, 30);

    // Fact quality (0-30) based on ratio of active to total facts
    if (totalFacts > 0) {
      const qualityRatio = Math.max(0, Math.min(1, activeFacts / totalFacts));
      rawScore += qualityRatio * 30;
    }

    // Diversity (0-15): categories/topics
    rawScore += Math.min(categoryCount * 1.5, 15);

    // Quality conversations (0-15)
    rawScore += Math.min(qualityConversations * 0.8, 15);

    // Engagement (0-10)
    rawScore += Math.min(conversationCount * 0.2, 10);

  // Penalty (subtract up to 80 points before scaling)
  // Heavier penalty for reported false replies and negative examples.
  // - falseReports are the strongest signal of incorrect behavior
  // - negativeExamples (user-provided corrections saved as negatives) are significant
  // - outdatedFacts are penalized but less strongly
  // Tuning: increase multipliers for stronger punishment of wrong answers.
  const penaltyPoints = Math.min((falseReports * 5) + (negativeExamples * 2.0) + (outdatedFacts * 0.5), 80);
    rawScore = Math.max(0, rawScore - penaltyPoints);

    // Ensure rawScore is within 0-100, then scale to 0-1000
    rawScore = Math.max(0, Math.min(100, rawScore));
    const finalScore = Math.round(rawScore * 10);

    // Update display
    learningScore.textContent = finalScore;

    // Labeling
    let label = 'Just starting';
    if (finalScore >= 900) label = 'Exceptional';
    else if (finalScore >= 700) label = 'Expert';
    else if (finalScore >= 500) label = 'Advanced';
    else if (finalScore >= 300) label = 'Intermediate';
    else if (finalScore >= 150) label = 'Learning';
    
    // Add timestamp to show last update
    const now = new Date();
    const timeStr = now.toLocaleTimeString();
    learningScoreLabel.textContent = `${label} ‚Ä¢ Updated ${timeStr}`;
    
    console.log(`[Learning Score] Updated: ${finalScore} (${label}) at ${timeStr}`);

    // Color grading
    if (finalScore >= 700) {
      learningScore.style.color = '#16a34a'; // green
    } else if (finalScore >= 500) {
      learningScore.style.color = '#60a5fa'; // blue
    } else if (finalScore >= 300) {
      learningScore.style.color = '#f59e0b'; // orange
    } else {
      learningScore.style.color = '#6b7280'; // gray
    }
    
  } catch (err) {
    console.error('Error updating learning score:', err);
    learningScore.textContent = '?';
    learningScoreLabel.textContent = 'Error';
  }
}

// Refresh button handler (also update learning score)
memRefreshBtn.onclick = async () => {
  await updateMemoryStats();
  await updateLearningScore();
};

exportAllBtn.onclick = () => {
  const blob = new Blob([JSON.stringify(conversations, null, 2)], { type: 'application/json' });
  const a = document.createElement('a');
  a.href = URL.createObjectURL(blob);
  a.download = 'all-conversations.json';
  document.body.appendChild(a); a.click(); a.remove();
};

const importAllBtn = document.getElementById('importAllBtn');
const importAllFile = document.getElementById('importAllFile');

importAllBtn.onclick = () => importAllFile.click();

importAllFile.addEventListener('change', async (ev) => {
  const f = ev.target.files[0]; if (!f) return;
  try {
    const txt = await f.text();
    const arr = JSON.parse(txt);
    if (Array.isArray(arr)) {
      conversations = arr;
      activeId = conversations[0]?.id || uid();
      renderTabs(); renderActive();
      // push all to server
      for (const c of conversations) {
        try { await apiCreate(c); } catch { /* ignore errors */ }
      }
      statusEl.textContent = 'All conversations imported';
    } else {
      alert('Invalid JSON format');
    }
  } catch {
    alert('Import failed');
  }
  importAllFile.value = '';
});


let conversations = [];
let activeId = null;

function uid(){ return 'c-' + Math.random().toString(36).slice(2,9); }
function getActive(){ return conversations.find(c => c.id === activeId); }

function renderTabs(){
  tabsEl.innerHTML = '';
  conversations.forEach(c => {
    const b = document.createElement('button');
    b.className = 'tab' + (c.id === activeId ? ' active' : '');
    b.textContent = c.title;
    b.onclick = () => setActive(c.id);
    tabsEl.appendChild(b);
  });
}

function renderActive(){
  const conv = getActive();
  if (!conv) return;
  convTitle.textContent = conv.title || 'Conversation';
  messagesEl.innerHTML = '';
  (conv.messages || []).forEach((m, idx) => appendMessage(m.text, m.role, new Date(m.timestamp), idx));
  promptEl.value = conv.draft || '';
  // Scroll to bottom so the newest message is visible and the send box remains in view
  messagesEl.scrollTop = messagesEl.scrollHeight;
}

function appendMessage(text, who = 'them', time = new Date(), index = 0){
  const conv = getActive();
  const row = document.createElement('div'); row.className = 'row';
  const bubble = document.createElement('div'); bubble.className = 'bubble ' + (who === 'me' ? 'me' : 'them');
  
  // Convert URLs to clickable links and preserve formatting
  const formattedText = text
    // Convert URLs to clickable links
    .replace(/(https?:\/\/[^\s]+)/g, '<a href="$1" target="_blank" rel="noopener noreferrer" style="color: #4a9eff; text-decoration: underline;">$1</a>')
    // Convert markdown bold to HTML
    .replace(/\*\*([^*]+)\*\*/g, '<strong>$1</strong>')
    // Convert newlines to <br>
    .replace(/\n/g, '<br>');
  
  bubble.innerHTML = formattedText;
  
  const meta = document.createElement('div'); meta.className = 'meta'; meta.textContent = time.toLocaleTimeString();

  // If this is an assistant message, add 'Report wrong' control and optionally 'Give better answer' when reported
  if (who !== 'me'){
    const msgObj = (conv && conv.messages && conv.messages[index]) ? conv.messages[index] : {};

    // If already reported as false, visually mark and show label
    if (msgObj.is_false) {
      bubble.classList.add('reported-false');
      const existingLabel = document.createElement('span'); existingLabel.className = 'false-label'; existingLabel.textContent = 'Marked false';
      bubble.appendChild(existingLabel);
    }

    const reportBtn = document.createElement('button');
    reportBtn.textContent = 'Report wrong';
    reportBtn.style.marginLeft = '8px';
    reportBtn.style.padding = '4px 8px';
    reportBtn.style.fontSize = '12px';
    reportBtn.style.borderRadius = '6px';
    reportBtn.className = 'secondary';
    reportBtn.onclick = async () => {
      const confirmReport = confirm('Mark this response as incorrect and request an improved answer?');
      if (!confirmReport) return;
      const correction = prompt('Optional: Provide the correct answer (helps training). Leave blank to skip.');
      try {
        const resp = await fetch('/api/feedback/mark_false', {
          method: 'POST', headers: {'Content-Type':'application/json'},
          body: JSON.stringify({ conv_id: conv.id, message_index: index, correction: correction })
        });
        if (!resp.ok) throw new Error(await resp.text());
        // Mark visually
        bubble.classList.add('reported-false');
        const lbl = document.createElement('span'); lbl.className = 'false-label'; lbl.textContent = 'Marked false';
        bubble.appendChild(lbl);
        // Update local conversation object and persist
        if (conv && conv.messages && conv.messages[index]){
          conv.messages[index].is_false = true;
          if (correction) conv.messages[index].user_correction = correction;
          try { await apiUpdate(conv); } catch(e){ console.warn('Failed to save reported state:', e); }
        }
        // Re-render to show 'Give better answer' control immediately
        renderActive();
        alert('Thank you ‚Äî the response has been flagged. You can now click "Give better answer" to ask Allie to try again.');
      } catch (err) {
        console.error('Report failed:', err);
        alert('Failed to report the response. See console for details.');
      }
    };
    meta.appendChild(reportBtn);

    // Show 'Give better answer' when message is reported as false
    const giveBetterBtn = document.createElement('button');
    giveBetterBtn.textContent = 'Give better answer';
    giveBetterBtn.style.marginLeft = '8px';
    giveBetterBtn.style.padding = '4px 8px';
    giveBetterBtn.style.fontSize = '12px';
    giveBetterBtn.style.borderRadius = '6px';
    giveBetterBtn.className = 'secondary';
    giveBetterBtn.onclick = async () => {
      const ok = confirm('Request Allie to provide a better answer now?');
      if (!ok) return;
      try {
        giveBetterBtn.disabled = true; giveBetterBtn.textContent = 'Requesting...';
        const resp = await fetch('/api/feedback/request_better', {
          method: 'POST', headers: {'Content-Type':'application/json'},
          body: JSON.stringify({ conv_id: conv.id, message_index: index })
        });
        if (!resp.ok) throw new Error(await resp.text());
        const j = await resp.json();
        const newReply = j.new_reply || j.newReply || (await resp.text());

        // Append new assistant reply locally and persist
        if (!conv.messages) conv.messages = [];
        conv.messages.push({ role: 'them', text: newReply, timestamp: Date.now() });
        try { await apiUpdate(conv); } catch(e){ console.warn('Failed to save conversation after better answer:', e); }
        renderActive();
        alert('Allie provided an improved answer. Check the conversation.');
      } catch (err) {
        console.error('Give better failed:', err);
        alert('Failed to request a better answer. See console for details.');
      } finally {
        giveBetterBtn.disabled = false; giveBetterBtn.textContent = 'Give better answer';
      }
    };

    // Only show this control if message is already flagged false
    if (msgObj.is_false) meta.appendChild(giveBetterBtn);
  }

  row.appendChild(bubble); row.appendChild(meta); messagesEl.appendChild(row);
  // Scroll to bottom so newest messages are visible above the input box
  messagesEl.scrollTop = messagesEl.scrollHeight;
}

function setActive(id){ activeId = id; renderTabs(); renderActive(); }

// API helpers
async function apiGetList(){
  const r = await fetch('/api/conversations');
  if (!r.ok) throw new Error(await r.text());
  const j = await r.json();
  if (!Array.isArray(j)) throw new Error('Server returned non-array conversations');
  return j;
}
async function apiCreate(conv){
  const r = await fetch('/api/conversations', { method:'POST', headers:{'Content-Type':'application/json'}, body:JSON.stringify(conv) });
  if (!r.ok) throw new Error(await r.text());
}
async function apiUpdate(conv){
  const r = await fetch('/api/conversations/' + encodeURIComponent(conv.id), { method:'PUT', headers:{'Content-Type':'application/json'}, body:JSON.stringify(conv) });
  if (!r.ok) throw new Error(await r.text());
}
async function apiDelete(id){
  const r = await fetch('/api/conversations/' + encodeURIComponent(id), { method:'DELETE' });
  if (!r.ok) throw new Error(await r.text());
}

// Learning API helpers
async function apiGetLearningStatus(){
  const r = await fetch('/api/learning/status');
  if (!r.ok) throw new Error(await r.text());
  return await r.json();
}

async function apiStartLearning(){
  const r = await fetch('/api/learning/start', { method:'POST' });
  if (!r.ok) throw new Error(await r.text());
  return await r.json();
}

async function apiGetLearningHistory(){
  const r = await fetch('/api/learning/history');
  if (!r.ok) throw new Error(await r.text());
  return await r.json();
}

// Load conversations on startup
async function loadConversations(){
  try {
    const list = await apiGetList();
    conversations = list;
    if (conversations.length === 0) {
      const first = { id: uid(), title: 'Allie', messages: [{role:'them', text:'Hi ‚Äî I am Allie. Ask me anything.', timestamp: Date.now()}], draft: '' };
      conversations.push(first);
      try { await apiCreate(first); } catch { /* ignore initial create error */ }
    }
    activeId = conversations[0].id;
    renderTabs();
    renderActive();
    statusEl.textContent = 'Connected';
  } catch (err) {
    console.error('Conversation load failed:', err);
    // Minimal usable fallback
    conversations = [{ id: uid(), title: 'Local', messages: [{role:'them', text:'Hi ‚Äî I am Allie. Ask me anything.', timestamp: Date.now()}], draft: '' }];
    activeId = conversations[0].id;
    renderTabs();
    renderActive();
    statusEl.textContent = 'Offline mode';
  }
}

// Actions
newBtn.onclick = async () => {
  const conv = { id: uid(), title: 'New conversation', messages: [{role:'them', text:'Hi ‚Äî I am Allie. Ask me anything.', timestamp: Date.now()}], draft: '' };
  conversations.unshift(conv);
  activeId = conv.id;
  renderTabs(); renderActive();
  try { await apiCreate(conv); statusEl.textContent = 'Connected'; } catch { statusEl.textContent = 'Offline mode'; }
};

renameBtn.onclick = async () => {
  const conv = getActive(); if (!conv) return;
  const name = prompt('Rename conversation', conv.title || 'Conversation');
  if (!name) return;
  conv.title = name;
  renderTabs(); renderActive();
  try { await apiUpdate(conv); statusEl.textContent = 'Connected'; } catch { statusEl.textContent = 'Offline mode'; }
};

deleteBtn.onclick = async () => {
  if (!confirm('Delete this conversation?')) return;
  const id = activeId;
  conversations = conversations.filter(c => c.id !== id);
  if (conversations.length === 0) {
    conversations = [{ id: uid(), title: 'Allie', messages: [{role:'them', text:'Hi ‚Äî I am Allie. Ask me anything.', timestamp: Date.now()}], draft: '' }];
  }
  activeId = conversations[0].id;
  renderTabs(); renderActive();
  try { await apiDelete(id); statusEl.textContent = 'Connected'; } catch { statusEl.textContent = 'Offline mode'; }
};

exportBtn.onclick = () => {
  const conv = getActive(); if (!conv) return;
  const blob = new Blob([JSON.stringify(conv, null, 2)], {type:'application/json'});
  const a = document.createElement('a'); a.href = URL.createObjectURL(blob); a.download = (conv.title || 'conversation') + '.json';
  document.body.appendChild(a); a.click(); a.remove();
};

importBtn.onclick = () => importFile.click();
importFile.addEventListener('change', async (ev) => {
  const f = ev.target.files[0]; if (!f) return;
  try {
    const txt = await f.text();
    const obj = JSON.parse(txt);
    if (!obj.id) obj.id = uid();
    conversations.unshift(obj); activeId = obj.id;
    renderTabs(); renderActive();
    try { await apiCreate(obj); statusEl.textContent = 'Connected'; } catch { statusEl.textContent = 'Offline mode'; }
  } catch { alert('Invalid JSON'); }
  importFile.value = '';
});

// Send flow
sendBtn.onclick = async () => {
  const txt = promptEl.value.trim(); if (!txt) return;
  const conv = getActive(); if (!conv) return;
  conv.draft = '';
  (conv.messages || (conv.messages = [])).push({ role: 'me', text: txt, timestamp: Date.now() });
  renderActive();
  promptEl.value = '';
  statusEl.textContent = 'Sending message...';

  try {
    const res = await fetch('/api/generate', {
      method: 'POST',
      headers: { 'Content-Type':'application/json' },
      body: JSON.stringify({
        prompt: txt,
        max_tokens: Number(maxTokensEl.value) || 120,
        // Send the current conversation messages to help resolve pronouns / context
        conversation_context: conv.messages || []
      })
    });
    if (!res.ok) throw new Error(await res.text());
    const j = await res.json();
    const reply = j.text || j.content || (Array.isArray(j) && j[0]?.text) || JSON.stringify(j);
    (conv.messages || (conv.messages = [])).push({ role: 'them', text: reply, timestamp: Date.now() });
    renderActive();
    try { 
      await apiUpdate(conv); 
      statusEl.textContent = 'Ready'; 
      // Update memory stats after message
      updateMemoryStats().catch(err => console.warn('Failed to update memory stats:', err));
      // Add learning activity for conversation processing
      addLearningActivity('Processed conversation message', 'info');
    } catch { 
      statusEl.textContent = 'Saved locally'; 
    }
  } catch (err) {
    (conv.messages || (conv.messages = [])).push({ role: 'them', text: 'Error: ' + err.message, timestamp: Date.now() });
    renderActive();
    statusEl.textContent = 'Error - check connection';
  }
};

promptEl.addEventListener('input', () => {
  const conv = getActive(); if (!conv) return;
  conv.draft = promptEl.value;
  // Fire-and-forget save
  apiUpdate(conv).catch(() => {});
});

// Learning event handlers
checkLearningBtn.onclick = async () => {
  try {
    const status = await apiGetLearningStatus();
    updateLearningStatus(status);
  } catch (err) {
    learningStatusEl.textContent = 'Error: ' + err.message;
    learningStatusEl.style.color = '#ff6b6b';
  }
};

startLearningBtn.onclick = async () => {
  try {
    startLearningBtn.disabled = true;
    startLearningBtn.textContent = 'Starting...';
    const result = await apiStartLearning();
    learningStatusEl.textContent = `Learning started: ${result.episode_id || 'episode'}`;
    learningStatusEl.style.color = '#60a5fa';
    // Switch to stop button
    startLearningBtn.style.display = 'none';
    stopLearningBtn.style.display = 'inline-block';
    // Refresh status after a delay
    setTimeout(() => checkLearningBtn.click(), 2000);
  } catch (err) {
    learningStatusEl.textContent = 'Error: ' + err.message;
    learningStatusEl.style.color = '#ff6b6b';
    startLearningBtn.disabled = false;
    startLearningBtn.textContent = 'Start Learning';
  }
};

stopLearningBtn.onclick = async () => {
  // For now, just refresh status - stopping learning would require additional API endpoint
  stopLearningBtn.disabled = true;
  stopLearningBtn.textContent = 'Stopping...';
  learningStatusEl.textContent = 'Stopping learning...';
  learningStatusEl.style.color = '#f59e0b';

  // Refresh status after a delay
  setTimeout(() => {
    checkLearningBtn.click();
    stopLearningBtn.disabled = false;
    stopLearningBtn.textContent = 'Stop Learning';
  }, 2000);
};

viewHistoryBtn.onclick = async () => {
  try {
    const history = await apiGetLearningHistory();
    if (history.history && history.history.length > 0) {
      const historyText = history.history.map(ep =>
        `${ep.id}: ${ep.status} (${new Date(ep.start_time * 1000).toLocaleString()})`
      ).join('\n');
      alert('Learning History:\n\n' + historyText);
    } else {
      alert('No learning history available');
    }
  } catch (err) {
    alert('Error loading history: ' + err.message);
  }
};

// Learning activity tracking
let lastLearningStatus = null;
let learningActivities = [];

function addLearningActivity(message, type = 'info') {
  const timestamp = new Date();
  const timeStr = timestamp.toLocaleTimeString();
  
  learningActivities.unshift({
    message,
    type,
    timestamp: timeStr,
    time: timestamp
  });
  
  // Keep only last 20 activities
  if (learningActivities.length > 20) {
    learningActivities = learningActivities.slice(0, 20);
  }
  
  updateLearningActivityFeed();
}

function updateLearningActivityFeed() {
  if (learningActivities.length === 0) {
    learningActivityFeed.innerHTML = '<div style="text-align:center;padding:8px;">No recent activity</div>';
    return;
  }
  
  const activitiesHtml = learningActivities.map(activity => {
    let icon = 'üìù';
    let color = 'var(--muted)';
    
    switch (activity.type) {
      case 'learning':
        icon = 'üß†';
        color = '#60a5fa';
        break;
      case 'success':
        icon = '‚úÖ';
        color = '#4ade80';
        break;
      case 'warning':
        icon = '‚ö†Ô∏è';
        color = '#f59e0b';
        break;
      case 'error':
        icon = '‚ùå';
        color = '#ff6b6b';
        break;
      default:
        icon = 'üìù';
        color = 'var(--muted)';
    }
    
    return `<div style="margin-bottom:4px;padding:4px;border-radius:3px;background:rgba(255,255,255,0.01);">
      <span style="color:${color};margin-right:4px;">${icon}</span>
      <span style="color:var(--text);font-size:10px;">${activity.timeStr}</span>
      <div style="margin-top:2px;color:var(--muted);">${activity.message}</div>
    </div>`;
  }).join('');
  
  learningActivityFeed.innerHTML = activitiesHtml;
}

function updateLearningStatus(status) {
  if (!status.enabled) {
    learningStatusEl.textContent = 'Learning system not available';
    learningStatusEl.style.color = '#ff6b6b';
    startLearningBtn.disabled = true;
    startLearningBtn.style.display = 'inline-block';
    stopLearningBtn.style.display = 'none';
    
    // Track status changes
    if (lastLearningStatus?.enabled !== false) {
      addLearningActivity('Learning system became unavailable', 'error');
    }
    lastLearningStatus = { enabled: false };
    return;
  }

  let statusText = '';
  let statusColor = '#9ca3af'; // default muted color
  let currentState = {
    is_active: status.is_active,
    should_learn: status.should_learn,
    auto_learning: status.auto_learning,
    auto_triggered: !!status.auto_triggered
  };

  if (status.auto_learning) {
    // Auto-learning is enabled
    if (status.is_active) {
      statusText = `Auto-learning active: ${status.current_episode?.status || 'running'}`;
      statusColor = '#60a5fa'; // accent color
      startLearningBtn.style.display = 'none';
      stopLearningBtn.style.display = 'inline-block';
      stopLearningBtn.disabled = false;
      
      // Check if learning just started
      if (!lastLearningStatus?.is_active) {
        addLearningActivity(`Auto-learning episode started (${status.current_episode?.id || 'unknown'})`, 'learning');
      }
    } else if (status.auto_triggered) {
      statusText = `Auto-triggered: ${status.auto_triggered.reason}`;
      statusColor = '#4ade80'; // green
      startLearningBtn.style.display = 'none';
      stopLearningBtn.style.display = 'none';
      
      // Check if auto-trigger just happened
      if (!lastLearningStatus?.auto_triggered) {
        addLearningActivity(`Auto-learning triggered: ${status.auto_triggered.reason}`, 'success');
      }
    } else if (status.should_learn) {
      statusText = '‚ö° Auto-learning ready - ' + (status.reason || 'Conditions met');
      statusColor = '#4ade80'; // green
      startLearningBtn.style.display = 'none';
      stopLearningBtn.style.display = 'none';
      
      // Check if conditions just became met
      if (!lastLearningStatus?.should_learn) {
        addLearningActivity('Learning conditions met - ready to learn', 'success');
      }
    } else {
      statusText = '‚è≥ Auto-learning enabled: ' + (status.reason || 'Waiting for conditions');
      statusColor = '#9ca3af'; // muted
      startLearningBtn.style.display = 'none';
      stopLearningBtn.style.display = 'none';
    }
  } else if (status.is_active) {
    statusText = `Learning active: ${status.current_episode?.status || 'running'}`;
    statusColor = '#60a5fa'; // accent color
    startLearningBtn.style.display = 'none';
    stopLearningBtn.style.display = 'inline-block';
    stopLearningBtn.disabled = false;
    
    // Check if learning just started
    if (!lastLearningStatus?.is_active) {
      addLearningActivity(`Manual learning episode started (${status.current_episode?.id || 'unknown'})`, 'learning');
    }
  } else if (status.should_learn) {
    statusText = 'Ready to learn - ' + (status.reason || 'Conditions met');
    statusColor = '#4ade80'; // green
    startLearningBtn.style.display = 'inline-block';
    startLearningBtn.disabled = false;
    stopLearningBtn.style.display = 'none';
    
    // Check if conditions just became met
    if (!lastLearningStatus?.should_learn) {
      addLearningActivity('Learning conditions met - ready to learn', 'success');
    }
  } else {
    statusText = 'Not ready: ' + (status.reason || 'Conditions not met');
    statusColor = '#9ca3af'; // muted
    startLearningBtn.style.display = 'inline-block';
    startLearningBtn.disabled = true;
    stopLearningBtn.style.display = 'none';
  }

  // Add system resource info if available
  if (status.system_resources) {
    const cpu = status.system_resources.cpu_percent;
    const mem = status.system_resources.memory_percent;
    if (cpu !== undefined && mem !== undefined) {
      statusText += ` | CPU: ${cpu.toFixed(0)}% | RAM: ${mem.toFixed(0)}%`;
    }
  }

  learningStatusEl.textContent = statusText;
  learningStatusEl.style.color = statusColor;
  
  // Store current state for next comparison
  lastLearningStatus = currentState;
}

// Init
(async function init(){
  await loadConversations();
  statusEl.textContent = 'Initializing...';

  // Add initial learning activities
  addLearningActivity('Allie AI interface loaded', 'info');
  addLearningActivity('Initializing conversation system', 'info');

  // Check learning status on load
  try {
    const status = await apiGetLearningStatus();
    updateLearningStatus(status);
    addLearningActivity('Learning system status checked', 'info');
  } catch (err) {
    learningStatusEl.textContent = 'Learning system unavailable';
    learningStatusEl.style.color = '#ff6b6b';
    addLearningActivity('Learning system unavailable', 'error');
  }

  // Load memory statistics on init
  await updateMemoryStats();
  
  // Load learning score on init
  await updateLearningScore();

  // Set up periodic status updates
  setInterval(async () => {
    try {
      const status = await apiGetLearningStatus();
      updateLearningStatus(status);
    } catch (err) {
      // Silently handle errors for periodic updates
      console.warn('Failed to update learning status:', err);
    }
  }, 30000); // Update every 30 seconds

  // Set up periodic memory stats updates
  setInterval(async () => {
    try {
      await updateMemoryStats();
      await updateLearningScore();
    } catch (err) {
      console.warn('Failed to update memory stats:', err);
    }
  }, 60000); // Update every 60 seconds

  statusEl.textContent = 'Ready';
  addLearningActivity('System ready and monitoring active', 'success');
  // Quick Teach button
  // Toggle between Chat and Quick Teach panels
  let currentPanel = 'chat';
  const quickTeachBtnEl = document.getElementById('quickTeachBtn');
  const chatPanelEl = document.getElementById('chatPanel');
  const quickTeachPanelEl = document.getElementById('quickTeachPanel');

  function showPanel(name){
    currentPanel = name;
    if (name === 'quick_teach'){
      chatPanelEl.style.display = 'none';
      quickTeachPanelEl.style.display = 'block';
      quickTeachBtnEl.classList.add('active');
    } else {
      chatPanelEl.style.display = 'block';
      quickTeachPanelEl.style.display = 'none';
      quickTeachBtnEl.classList.remove('active');
    }
  }

  quickTeachBtnEl.onclick = () => { showPanel(currentPanel === 'chat' ? 'quick_teach' : 'chat'); };
})();
</script>
</body>
</html>
