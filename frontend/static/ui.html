<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Allie ‚Äî Tabbed Conversations</title>
<style>
  :root{--bg:#0f1720;--panel:#0b1220;--muted:#9ca3af;--text:#e6eef6;--accent:#60a5fa;--me:#0b84ff}
  html,body{height:100%;margin:0;font-family:Inter,system-ui,Segoe UI,Arial;color:var(--text);overflow:hidden}
  .app{width:100%;height:100vh;background:var(--panel);border-radius:0;box-shadow:none;display:flex;overflow:hidden;box-sizing:border-box}
  .sidebar{width:260px;padding:12px;border-right:1px solid rgba(255,255,255,0.03);display:flex;flex-direction:column}
  .tabs{display:flex;flex-wrap:wrap;gap:6px}
  .tab{padding:8px 10px;border-radius:8px;background:transparent;color:var(--muted);cursor:pointer;border:1px solid transparent}
  .tab.active{background:rgba(255,255,255,0.05);color:var(--text);border-color:rgba(255,255,255,0.07)}
  .tab-controls{margin-top:10px;display:flex;gap:6px;flex-wrap:wrap}
  button{background:var(--accent);color:#021125;border:none;padding:8px 12px;border-radius:8px;cursor:pointer;font-weight:600}
  /* Larger chat input and send button adjustments */
  /* Make the main prompt textarea ~3x taller for easier typing */
  #prompt{
    height:120px; /* ~3x typical single-line input height */
    padding:14px;
    font-size:16px;
    border-radius:10px;
    border:1px solid rgba(255,255,255,0.04);
    background:transparent;
    color:var(--text);
    resize:vertical;
    min-height:84px;
    max-height:320px;
  }

  /* Make the SEND button visually and interactively larger (approx 3x) */
  #sendBtn{
    padding:24px 36px;
    font-size:18px;
    border-radius:10px;
    transform-origin:center;
  }

  /* Ensure the inputbar layout accommodates larger controls */
  .inputbar{display:flex;gap:16px;padding:12px}
  .inputbar > div{display:flex;flex-direction:column;align-items:flex-end}
  button.secondary{background:transparent;color:var(--muted);border:1px solid rgba(255,255,255,0.08)}
  .main{flex:1;display:flex;flex-direction:column;min-height:0}
  .header{padding:12px 16px;border-bottom:1px solid rgba(255,255,255,0.03);display:flex;align-items:center;gap:12px}
  .status-section{margin-left:auto;display:flex;flex-direction:column;gap:4px}
  .status-label{font-size:11px;color:var(--muted);text-transform:uppercase;letter-spacing:0.5px}
  .status-value{font-size:13px;color:var(--text);font-weight:500}
  .messages{flex:1;padding:16px;overflow:auto;display:flex;flex-direction:column;gap:12px;min-height:0;background:linear-gradient(180deg,rgba(255,255,255,0.02),transparent)}
  .row{display:flex;gap:10px;align-items:flex-end}
  .bubble{max-width:75%;padding:12px 14px;border-radius:13px;font-size:15px;line-height:1.4}
  .bubble.me{margin-left:auto;background:linear-gradient(90deg,var(--me),#1f7fe8);color:#021125;border-bottom-right-radius:6px}
  .bubble.them{margin-right:auto;background:#111827;border:1px solid rgba(255,255,255,0.02)}
  .meta{font-size:12px;color:var(--muted);margin-top:6px}
  .sidebar-status{margin-bottom:16px;padding:12px;border-radius:8px;background:rgba(255,255,255,0.02);border:1px solid rgba(255,255,255,0.05)}
  .sidebar-status-label{font-size:12px;color:var(--muted);text-transform:uppercase;letter-spacing:0.5px;margin-bottom:4px}
  .sidebar-status-value{font-size:16px;color:var(--text);font-weight:500}
  .learning-status{font-size:12px;color:var(--muted);margin-bottom:8px}
  .learning-controls{display:flex;flex-direction:column;gap:6px}
  .learning-btn{background:var(--accent);color:#021125;border:none;padding:6px 10px;border-radius:6px;cursor:pointer;font-size:12px;font-weight:600}
  .learning-btn.secondary{background:transparent;color:var(--muted);border:1px solid rgba(255,255,255,0.08)}
  .learning-btn:disabled{background:#666;color:#999;cursor:not-allowed}
  .memory-panel{width:240px;padding:12px;border-left:1px solid rgba(255,255,255,0.03);display:flex;flex-direction:column;gap:12px;overflow-y:auto}
  .memory-stats-card{background:rgba(255,255,255,0.02);border:1px solid rgba(255,255,255,0.05);border-radius:8px;padding:12px}
  .memory-stats-title{font-size:13px;color:var(--accent);font-weight:600;margin-bottom:8px;display:flex;align-items:center;gap:6px}
  .memory-stat-row{display:flex;justify-content:space-between;align-items:center;padding:6px 0;border-bottom:1px solid rgba(255,255,255,0.03)}
  .memory-stat-row:last-child{border-bottom:none}
  .memory-stat-label{font-size:12px;color:var(--muted)}
  .memory-stat-value{font-size:14px;color:var(--text);font-weight:600}
  .memory-category-item{display:flex;justify-content:space-between;font-size:11px;padding:4px 0;color:var(--muted)}
  .memory-refresh-btn{background:transparent;color:var(--accent);border:1px solid rgba(96,165,250,0.3);padding:6px 10px;border-radius:6px;cursor:pointer;font-size:11px;width:100%;margin-top:8px;font-weight:600;transition:all 0.2s}
  .memory-refresh-btn:hover{background:rgba(96,165,250,0.1);border-color:var(--accent)}
  .memory-refresh-btn:active{transform:scale(0.95)}
  .memory-refresh-btn.refreshing{opacity:0.5;pointer-events:none}
</style>
</head>
<body>
<div class="app" role="application" aria-label="Allie chat UI">
  <aside class="sidebar">
    <h3 style="margin:6px 4px;color:var(--accent);font-size:14px">Conversations</h3>
    <div class="sidebar-status">
      <div class="sidebar-status-label">Status</div>
      <div class="sidebar-status-value" id="status">Initializing...</div>
    </div>
    <div class="tabs" id="tabs"></div>
    <div class="tab-controls">
      <button id="newConv">New</button>
      <button id="renameConv" class="secondary">Rename</button>
      <button id="deleteConv" class="secondary">Delete</button>
    </div>

    <div class="learning-panel">
      <h4 style="margin:0 0 8px 0;color:var(--accent);font-size:13px">Learning System (Auto)</h4>
      <div id="learningStatus" class="learning-status">Initializing learning system...</div>
      <div class="learning-controls">
        <button id="checkLearningBtn" class="learning-btn secondary">Refresh Status</button>
        <button id="startLearningBtn" class="learning-btn" style="display:none">Manual Trigger</button>
        <button id="stopLearningBtn" class="learning-btn secondary" style="display:none">Stop Learning</button>
        <button id="viewHistoryBtn" class="learning-btn secondary">View History</button>
      </div>

      <!-- Learning Activity Feed -->
      <div class="learning-activity" style="margin-top:12px;">
        <h5 style="margin:0 0 6px 0;color:var(--accent);font-size:11px;text-transform:uppercase;letter-spacing:0.5px">Recent Activity</h5>
        <div id="learningActivityFeed" class="learning-activity-feed" style="max-height:120px;overflow-y:auto;font-size:11px;color:var(--muted);background:rgba(255,255,255,0.02);border-radius:6px;padding:8px;">
          <div style="text-align:center;padding:8px;">Loading activity...</div>
        </div>
      </div>
    </div>

    <div style="margin-top:auto;font-size:13px;color:var(--muted);padding-top:12px">Local model ¬∑ <span id="modelName">tinyllama</span></div>
  </aside>

  <main class="main">
    <div class="header">
      <div style="font-weight:600" id="convTitle">Allie</div>
      <div style="flex:1"></div>
      <button id="exportAllBtn" class="secondary">Export All</button>
      <button id="exportBtn" class="secondary">Export</button>
      <input id="importAllFile" type="file" style="display:none" accept=".json"/>
      <button id="importAllBtn" class="secondary">Import All</button>

      <input id="importFile" type="file" style="display:none" accept=".json"/>
      <button id="importBtn" class="secondary">Import</button>
    </div>

    <div class="messages" id="messages" aria-live="polite"></div>

    <div class="inputbar">
      <textarea id="prompt" placeholder="Send a message..."></textarea>
      <div style="display:flex;flex-direction:column;gap:6px;align-items:flex-end">
        <div style="display:flex;flex-direction:column;gap:6px">
          <button id="sendBtn">Send</button>
          <button id="stopBtn" class="secondary" style="display:none">Stop</button>
        </div>
        <div style="width:120px;text-align:right;color:var(--muted);font-size:12px">
          Max tokens<br/><input id="maxTokens" type="number" value="120" min="1" style="width:80px;margin-top:6px"/>
        </div>
      </div>
    </div>
  </main>

  <aside class="memory-panel">
    <div class="memory-stats-card" style="background:rgba(96,165,250,0.08);border-color:rgba(96,165,250,0.2)">
      <div class="memory-stats-title">
        <span>‚≠ê</span>
        <span>Learning Score</span>
      </div>
      <div style="text-align:center;padding:8px 0">
        <div style="font-size:32px;font-weight:700;color:var(--accent)" id="learningScore">-</div>
        <div style="font-size:11px;color:var(--muted);margin-top:4px" id="learningScoreLabel">Calculating...</div>
      </div>
    </div>

    <div class="memory-stats-card">
      <div class="memory-stats-title">
        <span>üß†</span>
        <span>Memory Stats</span>
      </div>
      <div class="memory-stat-row">
        <span class="memory-stat-label">Total Facts</span>
        <span class="memory-stat-value" id="memTotalFacts">-</span>
      </div>
      <div class="memory-stat-row">
        <span class="memory-stat-label">Active</span>
        <span class="memory-stat-value" id="memActiveFacts">-</span>
      </div>
      <div class="memory-stat-row">
        <span class="memory-stat-label">Outdated</span>
        <span class="memory-stat-value" id="memOutdatedFacts">-</span>
      </div>
      <div class="memory-stat-row">
        <span class="memory-stat-label">Keywords</span>
        <span class="memory-stat-value" id="memKeywords">-</span>
      </div>
      <button id="memRefreshBtn" class="memory-refresh-btn">‚Üª Refresh</button>
    </div>

    <div class="memory-stats-card">
      <div class="memory-stats-title">
        <span>üìÇ</span>
        <span>Categories</span>
      </div>
      <div id="memCategories" style="max-height:150px;overflow-y:auto">
        <div style="font-size:11px;color:var(--muted);text-align:center;padding:8px">Loading...</div>
      </div>
    </div>

    <div class="memory-stats-card">
      <div class="memory-stats-title">
        <span>üîó</span>
        <span>Sources</span>
      </div>
      <div id="memSources" style="max-height:120px;overflow-y:auto">
        <div style="font-size:11px;color:var(--muted);text-align:center;padding:8px">Loading...</div>
      </div>
    </div>

    <div class="memory-stats-card">
      <div class="memory-stats-title">
        <span>‚è±Ô∏è</span>
        <span>Last Updated</span>
      </div>
      <div style="font-size:11px;color:var(--muted);text-align:center;padding:8px" id="memLastUpdate">Never</div>
    </div>
  </aside>
</div>

<script>
/* Tabbed conversations UI with server-side persistence.
   Endpoints used:
   - GET    /api/conversations
   - POST   /api/conversations
   - PUT    /api/conversations/{id}
   - DELETE /api/conversations/{id}
   - POST   /api/generate  { prompt, max_tokens }
*/

const tabsEl = document.getElementById('tabs');
const messagesEl = document.getElementById('messages');
const promptEl = document.getElementById('prompt');
const sendBtn = document.getElementById('sendBtn');
const stopBtn = document.getElementById('stopBtn');
const newBtn = document.getElementById('newConv');
const renameBtn = document.getElementById('renameConv');
const deleteBtn = document.getElementById('deleteConv');
const convTitle = document.getElementById('convTitle');
const statusEl = document.getElementById('status');
const exportBtn = document.getElementById('exportBtn');
const importBtn = document.getElementById('importBtn');
const importFile = document.getElementById('importFile');
const maxTokensEl = document.getElementById('maxTokens');
const exportAllBtn = document.getElementById('exportAllBtn');

// Learning elements
const learningStatusEl = document.getElementById('learningStatus');
const checkLearningBtn = document.getElementById('checkLearningBtn');
const startLearningBtn = document.getElementById('startLearningBtn');
const stopLearningBtn = document.getElementById('stopLearningBtn');
const viewHistoryBtn = document.getElementById('viewHistoryBtn');
const learningActivityFeed = document.getElementById('learningActivityFeed');

// Memory statistics elements
const memTotalFacts = document.getElementById('memTotalFacts');
const memActiveFacts = document.getElementById('memActiveFacts');
const memOutdatedFacts = document.getElementById('memOutdatedFacts');
const memKeywords = document.getElementById('memKeywords');
const memCategories = document.getElementById('memCategories');
const memSources = document.getElementById('memSources');
const memLastUpdate = document.getElementById('memLastUpdate');
const memRefreshBtn = document.getElementById('memRefreshBtn');

// Learning score elements
const learningScore = document.getElementById('learningScore');
const learningScoreLabel = document.getElementById('learningScoreLabel');

// Fetch and update memory statistics
async function updateMemoryStats() {
  try {
    // Add visual feedback
    memRefreshBtn.classList.add('refreshing');
    memRefreshBtn.textContent = '‚ü≥ Refreshing...';
    
    const resp = await fetch('/api/hybrid-memory/statistics');
    if (!resp.ok) {
      console.error('Failed to fetch memory stats:', resp.status);
      memRefreshBtn.classList.remove('refreshing');
      memRefreshBtn.textContent = '‚Üª Refresh';
      return;
    }
    
    const data = await resp.json();
    const stats = data.statistics;
    
    // Update main stats
    memTotalFacts.textContent = stats.total_facts || 0;
    memActiveFacts.textContent = stats.active_facts || 0;
    memOutdatedFacts.textContent = stats.outdated_facts || 0;
    memKeywords.textContent = stats.indexed_keywords || 0;
    
    // Update categories
    const categoriesHtml = Object.entries(stats.categories || {})
      .sort((a, b) => b[1] - a[1])
      .map(([cat, count]) => `
        <div class="memory-category-item">
          <span>${cat}</span>
          <span style="color:var(--text);font-weight:600">${count}</span>
        </div>
      `).join('') || '<div style="font-size:11px;color:var(--muted);text-align:center;padding:8px">No categories</div>';
    memCategories.innerHTML = categoriesHtml;
    
    // Update sources
    const sourcesHtml = Object.entries(stats.sources || {})
      .sort((a, b) => b[1] - a[1])
      .map(([src, count]) => `
        <div class="memory-category-item">
          <span>${src}</span>
          <span style="color:var(--text);font-weight:600">${count}</span>
        </div>
      `).join('') || '<div style="font-size:11px;color:var(--muted);text-align:center;padding:8px">No sources</div>';
    memSources.innerHTML = sourcesHtml;
    
    // Update last update time
    const now = new Date();
    memLastUpdate.textContent = now.toLocaleTimeString();
    
    // Add learning activity for memory stats update
    const totalFacts = stats.total_facts || 0;
    if (totalFacts > 0) {
      addLearningActivity(`Memory updated: ${totalFacts} facts, ${stats.active_facts || 0} active`, 'info');
    }
    
    // Remove visual feedback
    memRefreshBtn.classList.remove('refreshing');
    memRefreshBtn.textContent = '‚Üª Refresh';
    
  } catch (err) {
    console.error('Error updating memory stats:', err);
    memTotalFacts.textContent = 'Error';
    memActiveFacts.textContent = '-';
    memOutdatedFacts.textContent = '-';
    memKeywords.textContent = '-';
    
    // Remove visual feedback on error
    memRefreshBtn.classList.remove('refreshing');
    memRefreshBtn.textContent = '‚Üª Refresh';
  }
}

// Refresh button handler
memRefreshBtn.onclick = updateMemoryStats;

// Calculate and update learning score
async function updateLearningScore() {
  try {
    // Fetch both memory stats and learning status
    const [memResp, learningResp] = await Promise.all([
      fetch('/api/hybrid-memory/statistics'),
      fetch('/api/learning/status')
    ]);
    
    if (!memResp.ok || !learningResp.ok) {
      learningScore.textContent = '?';
      learningScoreLabel.textContent = 'Error fetching data';
      return;
    }
    
    const memData = await memResp.json();
    const learningData = await learningResp.json();
    
    const stats = memData.statistics;
    const dataStats = learningData.data_stats || {};
    
    // Calculate learning score (0-100)
    // Factors:
    // - Active facts (40 points max): 1 point per fact, capped at 40
    // - Fact quality (30 points max): ratio of active to total facts
    // - Data diversity (20 points max): number of categories
    // - Recent learning (10 points max): based on conversation count
    
    const activeFacts = stats.active_facts || 0;
    const totalFacts = stats.total_facts || 0;
    const categoryCount = Object.keys(stats.categories || {}).length;
    const conversationCount = dataStats.total_conversations || 0;
    
    let score = 0;
    
    // Active facts contribution (40 points max)
    score += Math.min(activeFacts, 40);
    
    // Fact quality contribution (30 points max)
    if (totalFacts > 0) {
      const qualityRatio = activeFacts / totalFacts;
      score += qualityRatio * 30;
    }
    
    // Data diversity contribution (20 points max)
    score += Math.min(categoryCount * 2, 20);
    
    // Recent learning contribution (10 points max)
    score += Math.min(conversationCount, 10);
    
    // Round to whole number
    score = Math.round(score);
    
    // Update display
    learningScore.textContent = score;
    
    // Set label based on score
    let label = 'Getting started';
    if (score >= 90) label = 'Expert level!';
    else if (score >= 75) label = 'Advanced';
    else if (score >= 50) label = 'Intermediate';
    else if (score >= 25) label = 'Learning...';
    
    learningScoreLabel.textContent = label;
    
    // Add color gradient based on score
    if (score >= 75) {
      learningScore.style.color = '#22c55e'; // green
    } else if (score >= 50) {
      learningScore.style.color = '#60a5fa'; // blue (accent)
    } else if (score >= 25) {
      learningScore.style.color = '#f59e0b'; // orange
    } else {
      learningScore.style.color = '#6b7280'; // gray
    }
    
  } catch (err) {
    console.error('Error updating learning score:', err);
    learningScore.textContent = '?';
    learningScoreLabel.textContent = 'Error';
  }
}

// Refresh button handler (also update learning score)
memRefreshBtn.onclick = async () => {
  await updateMemoryStats();
  await updateLearningScore();
};

exportAllBtn.onclick = () => {
  const blob = new Blob([JSON.stringify(conversations, null, 2)], { type: 'application/json' });
  const a = document.createElement('a');
  a.href = URL.createObjectURL(blob);
  a.download = 'all-conversations.json';
  document.body.appendChild(a); a.click(); a.remove();
};

const importAllBtn = document.getElementById('importAllBtn');
const importAllFile = document.getElementById('importAllFile');

importAllBtn.onclick = () => importAllFile.click();

importAllFile.addEventListener('change', async (ev) => {
  const f = ev.target.files[0]; if (!f) return;
  try {
    const txt = await f.text();
    const arr = JSON.parse(txt);
    if (Array.isArray(arr)) {
      conversations = arr;
      activeId = conversations[0]?.id || uid();
      renderTabs(); renderActive();
      // push all to server
      for (const c of conversations) {
        try { await apiCreate(c); } catch { /* ignore errors */ }
      }
      statusEl.textContent = 'All conversations imported';
    } else {
      alert('Invalid JSON format');
    }
  } catch {
    alert('Import failed');
  }
  importAllFile.value = '';
});


let conversations = [];
let activeId = null;

function uid(){ return 'c-' + Math.random().toString(36).slice(2,9); }
function getActive(){ return conversations.find(c => c.id === activeId); }

function renderTabs(){
  tabsEl.innerHTML = '';
  conversations.forEach(c => {
    const b = document.createElement('button');
    b.className = 'tab' + (c.id === activeId ? ' active' : '');
    b.textContent = c.title;
    b.onclick = () => setActive(c.id);
    tabsEl.appendChild(b);
  });
}

function renderActive(){
  const conv = getActive();
  if (!conv) return;
  convTitle.textContent = conv.title || 'Conversation';
  messagesEl.innerHTML = '';
  (conv.messages || []).forEach(m => appendMessage(m.text, m.role, new Date(m.timestamp)));
  promptEl.value = conv.draft || '';
  messagesEl.scrollTop = messagesEl.scrollHeight;
}

function appendMessage(text, who = 'them', time = new Date()){
  const row = document.createElement('div'); row.className = 'row';
  const bubble = document.createElement('div'); bubble.className = 'bubble ' + (who === 'me' ? 'me' : 'them');
  
  // Convert URLs to clickable links and preserve formatting
  const formattedText = text
    // Convert URLs to clickable links
    .replace(/(https?:\/\/[^\s]+)/g, '<a href="$1" target="_blank" rel="noopener noreferrer" style="color: #4a9eff; text-decoration: underline;">$1</a>')
    // Convert markdown bold to HTML
    .replace(/\*\*([^*]+)\*\*/g, '<strong>$1</strong>')
    // Convert newlines to <br>
    .replace(/\n/g, '<br>');
  
  bubble.innerHTML = formattedText;
  
  const meta = document.createElement('div'); meta.className = 'meta'; meta.textContent = time.toLocaleTimeString();
  row.appendChild(bubble); row.appendChild(meta); messagesEl.appendChild(row);
  messagesEl.scrollTop = messagesEl.scrollHeight;
}

function setActive(id){ activeId = id; renderTabs(); renderActive(); }

// API helpers
async function apiGetList(){
  const r = await fetch('/api/conversations');
  if (!r.ok) throw new Error(await r.text());
  const j = await r.json();
  if (!Array.isArray(j)) throw new Error('Server returned non-array conversations');
  return j;
}
async function apiCreate(conv){
  const r = await fetch('/api/conversations', { method:'POST', headers:{'Content-Type':'application/json'}, body:JSON.stringify(conv) });
  if (!r.ok) throw new Error(await r.text());
}
async function apiUpdate(conv){
  const r = await fetch('/api/conversations/' + encodeURIComponent(conv.id), { method:'PUT', headers:{'Content-Type':'application/json'}, body:JSON.stringify(conv) });
  if (!r.ok) throw new Error(await r.text());
}
async function apiDelete(id){
  const r = await fetch('/api/conversations/' + encodeURIComponent(id), { method:'DELETE' });
  if (!r.ok) throw new Error(await r.text());
}

// Learning API helpers
async function apiGetLearningStatus(){
  const r = await fetch('/api/learning/status');
  if (!r.ok) throw new Error(await r.text());
  return await r.json();
}

async function apiStartLearning(){
  const r = await fetch('/api/learning/start', { method:'POST' });
  if (!r.ok) throw new Error(await r.text());
  return await r.json();
}

async function apiGetLearningHistory(){
  const r = await fetch('/api/learning/history');
  if (!r.ok) throw new Error(await r.text());
  return await r.json();
}

// Load conversations on startup
async function loadConversations(){
  try {
    const list = await apiGetList();
    conversations = list;
    if (conversations.length === 0) {
      const first = { id: uid(), title: 'Allie', messages: [{role:'them', text:'Hi ‚Äî I am Allie. Ask me anything.', timestamp: Date.now()}], draft: '' };
      conversations.push(first);
      try { await apiCreate(first); } catch { /* ignore initial create error */ }
    }
    activeId = conversations[0].id;
    renderTabs();
    renderActive();
    statusEl.textContent = 'Connected';
  } catch (err) {
    console.error('Conversation load failed:', err);
    // Minimal usable fallback
    conversations = [{ id: uid(), title: 'Local', messages: [{role:'them', text:'Hi ‚Äî I am Allie. Ask me anything.', timestamp: Date.now()}], draft: '' }];
    activeId = conversations[0].id;
    renderTabs();
    renderActive();
    statusEl.textContent = 'Offline mode';
  }
}

// Actions
newBtn.onclick = async () => {
  const conv = { id: uid(), title: 'New conversation', messages: [{role:'them', text:'Hi ‚Äî I am Allie. Ask me anything.', timestamp: Date.now()}], draft: '' };
  conversations.unshift(conv);
  activeId = conv.id;
  renderTabs(); renderActive();
  try { await apiCreate(conv); statusEl.textContent = 'Connected'; } catch { statusEl.textContent = 'Offline mode'; }
};

renameBtn.onclick = async () => {
  const conv = getActive(); if (!conv) return;
  const name = prompt('Rename conversation', conv.title || 'Conversation');
  if (!name) return;
  conv.title = name;
  renderTabs(); renderActive();
  try { await apiUpdate(conv); statusEl.textContent = 'Connected'; } catch { statusEl.textContent = 'Offline mode'; }
};

deleteBtn.onclick = async () => {
  if (!confirm('Delete this conversation?')) return;
  const id = activeId;
  conversations = conversations.filter(c => c.id !== id);
  if (conversations.length === 0) {
    conversations = [{ id: uid(), title: 'Allie', messages: [{role:'them', text:'Hi ‚Äî I am Allie. Ask me anything.', timestamp: Date.now()}], draft: '' }];
  }
  activeId = conversations[0].id;
  renderTabs(); renderActive();
  try { await apiDelete(id); statusEl.textContent = 'Connected'; } catch { statusEl.textContent = 'Offline mode'; }
};

exportBtn.onclick = () => {
  const conv = getActive(); if (!conv) return;
  const blob = new Blob([JSON.stringify(conv, null, 2)], {type:'application/json'});
  const a = document.createElement('a'); a.href = URL.createObjectURL(blob); a.download = (conv.title || 'conversation') + '.json';
  document.body.appendChild(a); a.click(); a.remove();
};

importBtn.onclick = () => importFile.click();
importFile.addEventListener('change', async (ev) => {
  const f = ev.target.files[0]; if (!f) return;
  try {
    const txt = await f.text();
    const obj = JSON.parse(txt);
    if (!obj.id) obj.id = uid();
    conversations.unshift(obj); activeId = obj.id;
    renderTabs(); renderActive();
    try { await apiCreate(obj); statusEl.textContent = 'Connected'; } catch { statusEl.textContent = 'Offline mode'; }
  } catch { alert('Invalid JSON'); }
  importFile.value = '';
});

// Send flow
sendBtn.onclick = async () => {
  const txt = promptEl.value.trim(); if (!txt) return;
  const conv = getActive(); if (!conv) return;
  conv.draft = '';
  (conv.messages || (conv.messages = [])).push({ role: 'me', text: txt, timestamp: Date.now() });
  renderActive();
  promptEl.value = '';
  statusEl.textContent = 'Sending message...';

  try {
    const res = await fetch('/api/generate', {
      method: 'POST',
      headers: { 'Content-Type':'application/json' },
      body: JSON.stringify({
        prompt: txt,
        max_tokens: Number(maxTokensEl.value) || 120,
        // Send the current conversation messages to help resolve pronouns / context
        conversation_context: conv.messages || []
      })
    });
    if (!res.ok) throw new Error(await res.text());
    const j = await res.json();
    const reply = j.text || j.content || (Array.isArray(j) && j[0]?.text) || JSON.stringify(j);
    (conv.messages || (conv.messages = [])).push({ role: 'them', text: reply, timestamp: Date.now() });
    renderActive();
    try { 
      await apiUpdate(conv); 
      statusEl.textContent = 'Ready'; 
      // Update memory stats after message
      updateMemoryStats().catch(err => console.warn('Failed to update memory stats:', err));
      // Add learning activity for conversation processing
      addLearningActivity('Processed conversation message', 'info');
    } catch { 
      statusEl.textContent = 'Saved locally'; 
    }
  } catch (err) {
    (conv.messages || (conv.messages = [])).push({ role: 'them', text: 'Error: ' + err.message, timestamp: Date.now() });
    renderActive();
    statusEl.textContent = 'Error - check connection';
  }
};

promptEl.addEventListener('input', () => {
  const conv = getActive(); if (!conv) return;
  conv.draft = promptEl.value;
  // Fire-and-forget save
  apiUpdate(conv).catch(() => {});
});

// Learning event handlers
checkLearningBtn.onclick = async () => {
  try {
    const status = await apiGetLearningStatus();
    updateLearningStatus(status);
  } catch (err) {
    learningStatusEl.textContent = 'Error: ' + err.message;
    learningStatusEl.style.color = '#ff6b6b';
  }
};

startLearningBtn.onclick = async () => {
  try {
    startLearningBtn.disabled = true;
    startLearningBtn.textContent = 'Starting...';
    const result = await apiStartLearning();
    learningStatusEl.textContent = `Learning started: ${result.episode_id || 'episode'}`;
    learningStatusEl.style.color = '#60a5fa';
    // Switch to stop button
    startLearningBtn.style.display = 'none';
    stopLearningBtn.style.display = 'inline-block';
    // Refresh status after a delay
    setTimeout(() => checkLearningBtn.click(), 2000);
  } catch (err) {
    learningStatusEl.textContent = 'Error: ' + err.message;
    learningStatusEl.style.color = '#ff6b6b';
    startLearningBtn.disabled = false;
    startLearningBtn.textContent = 'Start Learning';
  }
};

stopLearningBtn.onclick = async () => {
  // For now, just refresh status - stopping learning would require additional API endpoint
  stopLearningBtn.disabled = true;
  stopLearningBtn.textContent = 'Stopping...';
  learningStatusEl.textContent = 'Stopping learning...';
  learningStatusEl.style.color = '#f59e0b';

  // Refresh status after a delay
  setTimeout(() => {
    checkLearningBtn.click();
    stopLearningBtn.disabled = false;
    stopLearningBtn.textContent = 'Stop Learning';
  }, 2000);
};

viewHistoryBtn.onclick = async () => {
  try {
    const history = await apiGetLearningHistory();
    if (history.history && history.history.length > 0) {
      const historyText = history.history.map(ep =>
        `${ep.id}: ${ep.status} (${new Date(ep.start_time * 1000).toLocaleString()})`
      ).join('\n');
      alert('Learning History:\n\n' + historyText);
    } else {
      alert('No learning history available');
    }
  } catch (err) {
    alert('Error loading history: ' + err.message);
  }
};

// Learning activity tracking
let lastLearningStatus = null;
let learningActivities = [];

function addLearningActivity(message, type = 'info') {
  const timestamp = new Date();
  const timeStr = timestamp.toLocaleTimeString();
  
  learningActivities.unshift({
    message,
    type,
    timestamp: timeStr,
    time: timestamp
  });
  
  // Keep only last 20 activities
  if (learningActivities.length > 20) {
    learningActivities = learningActivities.slice(0, 20);
  }
  
  updateLearningActivityFeed();
}

function updateLearningActivityFeed() {
  if (learningActivities.length === 0) {
    learningActivityFeed.innerHTML = '<div style="text-align:center;padding:8px;">No recent activity</div>';
    return;
  }
  
  const activitiesHtml = learningActivities.map(activity => {
    let icon = 'üìù';
    let color = 'var(--muted)';
    
    switch (activity.type) {
      case 'learning':
        icon = 'üß†';
        color = '#60a5fa';
        break;
      case 'success':
        icon = '‚úÖ';
        color = '#4ade80';
        break;
      case 'warning':
        icon = '‚ö†Ô∏è';
        color = '#f59e0b';
        break;
      case 'error':
        icon = '‚ùå';
        color = '#ff6b6b';
        break;
      default:
        icon = 'üìù';
        color = 'var(--muted)';
    }
    
    return `<div style="margin-bottom:4px;padding:4px;border-radius:3px;background:rgba(255,255,255,0.01);">
      <span style="color:${color};margin-right:4px;">${icon}</span>
      <span style="color:var(--text);font-size:10px;">${activity.timeStr}</span>
      <div style="margin-top:2px;color:var(--muted);">${activity.message}</div>
    </div>`;
  }).join('');
  
  learningActivityFeed.innerHTML = activitiesHtml;
}

function updateLearningStatus(status) {
  if (!status.enabled) {
    learningStatusEl.textContent = 'Learning system not available';
    learningStatusEl.style.color = '#ff6b6b';
    startLearningBtn.disabled = true;
    startLearningBtn.style.display = 'inline-block';
    stopLearningBtn.style.display = 'none';
    
    // Track status changes
    if (lastLearningStatus?.enabled !== false) {
      addLearningActivity('Learning system became unavailable', 'error');
    }
    lastLearningStatus = { enabled: false };
    return;
  }

  let statusText = '';
  let statusColor = '#9ca3af'; // default muted color
  let currentState = {
    is_active: status.is_active,
    should_learn: status.should_learn,
    auto_learning: status.auto_learning,
    auto_triggered: !!status.auto_triggered
  };

  if (status.auto_learning) {
    // Auto-learning is enabled
    if (status.is_active) {
      statusText = `Auto-learning active: ${status.current_episode?.status || 'running'}`;
      statusColor = '#60a5fa'; // accent color
      startLearningBtn.style.display = 'none';
      stopLearningBtn.style.display = 'inline-block';
      stopLearningBtn.disabled = false;
      
      // Check if learning just started
      if (!lastLearningStatus?.is_active) {
        addLearningActivity(`Auto-learning episode started (${status.current_episode?.id || 'unknown'})`, 'learning');
      }
    } else if (status.auto_triggered) {
      statusText = `Auto-triggered: ${status.auto_triggered.reason}`;
      statusColor = '#4ade80'; // green
      startLearningBtn.style.display = 'none';
      stopLearningBtn.style.display = 'none';
      
      // Check if auto-trigger just happened
      if (!lastLearningStatus?.auto_triggered) {
        addLearningActivity(`Auto-learning triggered: ${status.auto_triggered.reason}`, 'success');
      }
    } else if (status.should_learn) {
      statusText = '‚ö° Auto-learning ready - ' + (status.reason || 'Conditions met');
      statusColor = '#4ade80'; // green
      startLearningBtn.style.display = 'none';
      stopLearningBtn.style.display = 'none';
      
      // Check if conditions just became met
      if (!lastLearningStatus?.should_learn) {
        addLearningActivity('Learning conditions met - ready to learn', 'success');
      }
    } else {
      statusText = '‚è≥ Auto-learning enabled: ' + (status.reason || 'Waiting for conditions');
      statusColor = '#9ca3af'; // muted
      startLearningBtn.style.display = 'none';
      stopLearningBtn.style.display = 'none';
    }
  } else if (status.is_active) {
    statusText = `Learning active: ${status.current_episode?.status || 'running'}`;
    statusColor = '#60a5fa'; // accent color
    startLearningBtn.style.display = 'none';
    stopLearningBtn.style.display = 'inline-block';
    stopLearningBtn.disabled = false;
    
    // Check if learning just started
    if (!lastLearningStatus?.is_active) {
      addLearningActivity(`Manual learning episode started (${status.current_episode?.id || 'unknown'})`, 'learning');
    }
  } else if (status.should_learn) {
    statusText = 'Ready to learn - ' + (status.reason || 'Conditions met');
    statusColor = '#4ade80'; // green
    startLearningBtn.style.display = 'inline-block';
    startLearningBtn.disabled = false;
    stopLearningBtn.style.display = 'none';
    
    // Check if conditions just became met
    if (!lastLearningStatus?.should_learn) {
      addLearningActivity('Learning conditions met - ready to learn', 'success');
    }
  } else {
    statusText = 'Not ready: ' + (status.reason || 'Conditions not met');
    statusColor = '#9ca3af'; // muted
    startLearningBtn.style.display = 'inline-block';
    startLearningBtn.disabled = true;
    stopLearningBtn.style.display = 'none';
  }

  // Add system resource info if available
  if (status.system_resources) {
    const cpu = status.system_resources.cpu_percent;
    const mem = status.system_resources.memory_percent;
    if (cpu !== undefined && mem !== undefined) {
      statusText += ` | CPU: ${cpu.toFixed(0)}% | RAM: ${mem.toFixed(0)}%`;
    }
  }

  learningStatusEl.textContent = statusText;
  learningStatusEl.style.color = statusColor;
  
  // Store current state for next comparison
  lastLearningStatus = currentState;
}

// Init
(async function init(){
  await loadConversations();
  statusEl.textContent = 'Initializing...';

  // Add initial learning activities
  addLearningActivity('Allie AI interface loaded', 'info');
  addLearningActivity('Initializing conversation system', 'info');

  // Check learning status on load
  try {
    const status = await apiGetLearningStatus();
    updateLearningStatus(status);
    addLearningActivity('Learning system status checked', 'info');
  } catch (err) {
    learningStatusEl.textContent = 'Learning system unavailable';
    learningStatusEl.style.color = '#ff6b6b';
    addLearningActivity('Learning system unavailable', 'error');
  }

  // Load memory statistics on init
  await updateMemoryStats();
  
  // Load learning score on init
  await updateLearningScore();

  // Set up periodic status updates
  setInterval(async () => {
    try {
      const status = await apiGetLearningStatus();
      updateLearningStatus(status);
    } catch (err) {
      // Silently handle errors for periodic updates
      console.warn('Failed to update learning status:', err);
    }
  }, 30000); // Update every 30 seconds

  // Set up periodic memory stats updates
  setInterval(async () => {
    try {
      await updateMemoryStats();
      await updateLearningScore();
    } catch (err) {
      console.warn('Failed to update memory stats:', err);
    }
  }, 60000); // Update every 60 seconds

  statusEl.textContent = 'Ready';
  addLearningActivity('System ready and monitoring active', 'success');
})();
</script>
</body>
</html>
